<!--
This is the famous Showreel example shipped with D3
http://bl.ocks.org/1256572
-->
<!DOCTYPE html>
<html>
  <head>
    <script src="http://d3js.org/d3.v2.js"></script>
    <style type="text/css">

svg {
  display: block;
  margin: auto;
  font-family: "Helvetica Neue";
}

.line {
  fill: none;
  stroke: #000;
  stroke-width: 2px;
}

    </style>
  </head>
  <body>
    <script type="text/javascript">

var tooltip = d3.select("body")
	.append("div")
	.style("position", "absolute")
	.style("z-index", "10")
	.style("visibility", "hidden")
	.text("Tooltip default text");

var margin = {top: 10, right: 10, bottom: 10, left: 10},
    width = 800 - margin.right - margin.left,
    height = 500 - margin.top - margin.bottom;

var duration = 1500,
    delay = 500;

var color = d3.scale.category10();

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var symbols,
    nametable,
    timetable,
    bands;

function cid2name(cid) {
    if (cid == -1) {
        return "OTHER";
    } else {
        return nametable[cid];
    }
}

function tix2time(tix) {
    return timetable[tix];
}

var x, y, line, axis, area;

var interpol = "linear"; // "basis"
var showbands = 10;

var loc = window.location.hash ? window.location.hash.substr(1) : "ee0029431bb4cf2941d0444782e7f291000214a6";
d3.json("http://heap.ezyang.com/view/" + loc, function(heap) {
  symbols = heap.data;
  timetable = heap.timetable;
  nametable = heap.nametable;

  bands = symbols.length;

  x = d3.time.scale()
      .range([0, width - 60]);

  y = d3.scale.linear();

  // A line generator, for the dark stroke.
  line = d3.svg.line()
      .interpolate(interpol)
      .x(function(d,i) { return x(tix2time(i)); })
      .y(function(d) { return y(d.y); });

  // A line generator, for the dark stroke.
  axis = d3.svg.line()
      .interpolate(interpol)
      .x(function(d,i) { return x(tix2time(i)); })
      .y(height);

  // A area generator, for the dark stroke.
  area = d3.svg.area()
      .interpolate(interpol)
      .x(function(d,i) { return x(tix2time(i)); })

  symbols.forEach(function(s) {
    s.maxUsage = d3.max(s.values, function(d) { return d.y; });
    s.sumUsage = d3.sum(s.values, function(d) { return d.y; });
  });
  symbols.sort(function(a, b) { return b.maxUsage - a.maxUsage; });

  // Separate high and low contributors
  var high = []
  var i = 0;
  while (symbols.length && i < showbands - 1) {
      high.push(symbols.shift());
      i++;
  }
  if (symbols.length) {
    var s = {
           cid: -1,
           values: d3.transpose(symbols.map(function (s) {
                       return s.values.map(function (d) { return d.y; });
                    })).map(function (x) { return {y: d3.sum(x)}; })
    };
    s.maxUsage = d3.max(s.values, function(d) { return d.y; });
    s.sumUsage = d3.sum(s.values, function(d) { return d.y; });
    high.push(s);
  }
  symbols = high;
  symbols.sort(function(a, b) { return b.maxUsage - a.maxUsage; });

  // Compute the minimum and maximum time across symbols.
  x.domain([tix2time(0), tix2time(timetable.length-1)]);

  var g = svg.selectAll("g")
      .data(symbols)
    .enter().append("g")
      .attr("class", "symbol");

  g.each(function(d) {
    d3.select(this).selectAll(".area")
        .data(d3.range(1))
      .enter().insert("path", ".line")
        .attr("class", "area")
        .style("fill", color(d.cid))
        .style("opacity", .6)
      .on("mouseover", function(){
      	  	  d3.select(d3.event.target).transition()
         .style("opacity", 1);
      return tooltip.style("visibility", "visible").text(cid2name(d.cid));})
	  .on("mousemove", function(){
	  return tooltip.style("top", (d3.event.pageY-10)+"px").style("left",(d3.event.pageX+10)+"px");})
	  .on("mouseout", function(){
	  d3.select(d3.event.target).transition()
      .style("opacity", .6);
	  return tooltip.style("visibility", "hidden");});
  });

  setTimeout(stackedArea, 0);

});
var first = true;
GraphEnum = {
	STACKED:0,
	STREAM:1,
	OVERLAY:2
	}	
var currGraph = GraphEnum.STACKED;

function stackedArea() {
  var stack = d3.layout.stack()
      .values(function(s) { return s.values; })
      .x(function(d,i) { return tix2time(i); })
      .y(function(d) { return d.y; })
      .out(function(d, y0, y) { d.y0 = y0; })
      .order("reverse");

  stack(symbols);

  y
      .domain([0, d3.max(symbols[0].values.map(function(d) { return d.y + d.y0; }))])
      .range([height, 0]);

  line
      .y(function(d) { return y(d.y0); });

  area
      .y0(function(d) { return y(d.y0); })
      .y1(function(d) { return y(d.y0 + d.y); });

  var t = svg.selectAll(".symbol").transition()
        .duration(duration/2);


  var easing = function (t) {
      return 1 - (1-t)*(1-t)*(1-t);
  }
  var easeOver = showbands * 150;

  t.select("path.area")
    .delay(function(d, i) { return (first||currGraph==GraphEnum.STREAM) ? 0 : easeOver * easing(i/showbands); })
    .style("fill-opacity", 1)
    .attr("d", function(d) { return area(d.values); });
  currGraph = GraphEnum.STACKED;
  //setTimeout(streamgraph, duration/2 + delay + (first ? 0 : easeOver));
}

function streamgraph() {
  first = false; // bum bum XXX
  var stack = d3.layout.stack()
      .values(function(d) { return d.values; })
      .x(function(d,i) { return tix2time(i); })
      .y(function(d) { return d.y; })
      .out(function(d, y0, y) { d.y0 = y0; })
      .order("reverse")
      .offset("wiggle");

  stack(symbols);

  line
      .y(function(d) { return y(d.y0); });

  area
      .y0(function(d) { return y(d.y0); })
      .y1(function(d) { return y(d.y0 + d.y); });

  var t = svg.selectAll(".symbol").transition()
      .duration(duration);

  t.select("path.area")
      .attr("d", function(d) { return area(d.values); });

  t.select("path.line")
      .style("stroke-opacity", 1e-6)
      .attr("d", function(d) { return line(d.values); });
  t.select(".area")
      .style("fill-opacity", 1)
      .attr("d", function(d) { return area(d.values); });
  currGraph = GraphEnum.STREAM;
  //setTimeout(overlappingArea, duration + delay);
}

function overlappingArea() {
  var g = svg.selectAll(".symbol");

  line
      .y(function(d) { return y(d.y0 + d.y); });

  g.select(".line")
      .attr("d", function(d) { return line(d.values); });

  y
      // XXX Using this scale keeps it consistent with the stackedArea scale,
      // which makes it visually easier to see the update.
      .domain([0, d3.max(symbols[0].values.map(function(d) { return d.y + d.y0; }))])
      //.domain([0, d3.max(symbols.map(function(d) { return d.maxUsage; }))])
      .range([height, 0]);

  area
      .y0(height)
      .y1(function(d) { return y(d.y); });

  line
      .y(function(d) { return y(d.y); });

  var t = g.transition()
      .duration(duration);

  t.select(".line")
      .style("stroke-opacity", 1)
      .attr("d", function(d) { return line(d.values); });

  t.select(".area")
      //.style("fill-opacity", .5)
      .attr("d", function(d) { return area(d.values); });

  svg.append("line")
      .attr("class", "line")
      .attr("x1", 0)
      .attr("x2", width - 60)
      .attr("y1", height)
      .attr("y2", height)
      .style("stroke-opacity", 1e-6)
      .transition()
      .duration(duration)
      .style("stroke-opacity", 1);
  currGraph = GraphEnum.OVERLAY;
  //setTimeout(stackedArea, duration + delay);


}

function annotate() {
A = document.annotationForm.annotation.value
}

    </script>
    <button id="stream" title="Toggle between streamgraph, stackgraph or overlay chart" onclick="streamgraph()">Stream Graph</button>
    <button id="stack" title="Toggle between streamgraph, stackgraph or overlay chart" onclick="stackedArea()">Stacked Graph</button>
    <button id="overlay" title="Toggle between streamgraph, stackgraph or overlay chart" onclick="overlappingArea()">Overlayed area Graph</button></br>
<FORM NAME = annotationForm>
Annotation to add: <INPUT TYPE = Text NAME = annotation SIZE = 20 value ="">
<P>
<Input Type = Button NAME = b1 VALUE = "Add text" onClick = "annotate()">

</FORM>
  </body>
</html>
