<!--
This is the famous Showreel example shipped with D3
http://bl.ocks.org/1256572
-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script src="http://d3js.org/d3.v2.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
    <style type="text/css">

svg {
  display: block;
  margin: auto;
  font-family: "Helvetica Neue";
}

.line {
  fill: none;
  stroke: #000;
  stroke-width: 2px;
}

.annot circle {
  stroke: #000;
  stroke-width: 2px;
}

.annot text {
  font-size: 12px;
}

.band {
  /*
  transition-property: opacity;
  transition-duration: 100ms;
  transition-timing-function: linear;
  */
}

.axis {
  font-size:12px;
}

.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.namefield {
  font-size:12px;
}

    </style>
  </head>
  <body>
    <script type="text/javascript">

/*
 known bugs:
  - click on annotation dot should trigger textbox
  - delete annotation by clearing contents
  - annotation edits don't work
  - axes sometimes don't render properly on refresh
  - cannot save annotations to other
  - disappear captions when they're not around
  - interaction mechanism is not clear about how to interact with the scrubs
  - scrub should have two windows and zoom on the big one
 */

// variable naming convention:
//    s = sequence (e.g. the entire "line" for a cost center)
//    d = data point (a particular (time, usage) point for a cost center)
//    a = annotation point
//    i,j,k = indexes

// ----------------------------------------------------------------------------
// some parameters

var interpol = "linear"; // "basis" will cause problems with annotation placement
var showbands = 10; // how many bands to show (the last band will be "OTHER")

var margin = {top: 30, right: 200, bottom: 40, left: 50},
    width = 800 - margin.right - margin.left,
    height = 550 - margin.top - margin.bottom;

var duration = 1500,
    delay = 500;

var annotCircleR = 5;
var annotCircleUnfocusR = 2;

var color = d3.scale.category10();

// ----------------------------------------------------------------------------
// global widgets which are independent of data
//    and forward declarations for elements that will be defined later

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var namegroup = svg.append("g");

var namebox = namegroup.append("rect")
  .attr("transform", "translate(0,-24)")
  .attr("class", "namebox")
  .style("opacity", 0)
  .attr("height", 20)
  .attr("width", width);
var namefield = namegroup.append("text")
  .attr("transform", "translate(2,-10)")
  .attr("class", "namefield");

var form;     // form element used to submit annotations
var yaxisbox; // box which contains the y-axis (needs to change)
var pie;      // pie chart on bottom right

// ----------------------------------------------------------------------------
// The data types

// Haskell style type signatures for extensions for known-length lists
// [t1, t2 ...] and objects {f1 :: t1, f2 :: t2}; also we write in curried style.

// type Cid = Int
// type Tix = Int
// type Datapoint = {y :: Int}
// type Series =
//     { cid         :: Cid
//     , values      :: [Datapoint] -- index is Tix
//     , annotations :: [{tix :: Tix, text :: String}]
//     }

var symbols,   // :: [Series] -- index is Cid
    nametable, // :: [String] -- index is Cid
    timetable; // :: [Double] -- index is Tix

var slim,      // :: [Series] -- index is NOT Cid
    others;    // :: [Series] -- ditto

var aggregate; // :: [{y :: Int}]

// ----------------------------------------------------------------------------
// Application modes

var first = true; // first render animates differently
var dragging = false;
var InteractEnum = {
  SELECT: 0, // we are selecting a data point to annotate
  ENTRY: 1  // we have an active form element for annotation
}
var GraphEnum = {
  STACKED:0,
  STREAM:1,
  OVERLAY:2,
  NORMALIZED:3,
  LINE:4
  }
var interactionMode = InteractEnum.SELECT;
var currGraph = GraphEnum.STACKED;
var nextGraph;

// use these to calculate various parameters regardless of how we've scaled things
var x, y, line, xaxis, yaxis, area;

var backend = "http://heap.ezyang.com";
//var backend = "http://localhost:3000";

// hack for ease of development
var loc = window.location.hash ? window.location.hash.substr(1) : "ee0029431bb4cf2941d0444782e7f291000214a6";


// ----------------------------------------------------------------------------
// Utility functions

// cid2name :: Cid -> String
function cid2name(cid) {
    if (cid == -1) {
        return "OTHER";
    } else {
        return nametable[cid];
    }
}

// tix2time :: Tix -> Double
function tix2time(tix) {
    return timetable[tix];
}

// sumColumns :: [{values: [{y: Int}]}] -> [{y: Int}]
function sumColumns(matrix) {
  return d3.transpose(matrix.map(function (s) {
     return s.values.map(function (d) { return d.y; });
  })).map(function (x) { return {y: d3.sum(x)}; })
}

// calcCoords :: Series -> Tix -> [Int,Int]
function calcCoords(s, tix) {
  return [x(tix2time(tix)), (first ? height : y((s.values[tix].y+s.values[tix].y0)/(currGraph == GraphEnum.NORMALIZED ? aggregate[tix].y : 1)))]
}

// standardTranslate :: Series -> Datapoint -> String (SVG translate)
function standardTranslate(s, d) {
  var r = calcCoords(s, d.tix);
  return "translate("+r[0]+","+r[1]+")";
}

// mouseoverBand :: Cid -> IO ()
function mouseoverBand(symbols, cid) {
  if (dragging) return;
  namefield.text(cid2name(cid))
  namebox.style("fill", color(cid))
    .style("opacity", 0.6);
  updateLegend(symbols, cid);
  updatePie(symbols, cid);
  updateAreas(symbols, cid);
}

// mouseoutBand :: Cid -> IO ()
function mouseoutBand(symbols, cid) {
  if (dragging) return;
  namefield.text("")
  namebox.style("opacity", 0);
  updateLegend(symbols);
  updatePie(symbols);
  updateAreas(symbols);
}

// xcoord2tix :: Int -> Tix
// reverse engineers an SVG relative pixel into a tix
function xcoord2tix(xpixel) {
  var xinv = x.invert(xpixel);
  var rightCand = d3.bisectRight(timetable, xinv);
  var leftCand = rightCand-1;
  return leftCand < 0 || tix2time(rightCand)-xinv < xinv-tix2time(leftCand) ? rightCand : leftCand;
}

// ----------------------------------------------------------------------------
// Update functions; the workhorses

function updateAnnotations(symbols) {
  // JOIN
  var annotBand = svg.selectAll(".annotBand").data(symbols);
  annotBand.enter().append("g")
    .attr("class", "annotBand");
  annotBand.each(function (s,i) {
    // JOIN
    var annot = d3.select(this).selectAll(".annot").data(s.annotations);
    annot.enter().append("g")
      .attr("class", "annot")
      .attr("transform", function(d) { return standardTranslate(s, d); }) // XXX bleh, shouldn't be necessary
      .call(function (g) {
        g.append("circle")
          .attr("r", annotCircleR)
          .style("fill", d3.hsl(color(s.cid)).darker())
        g.append("text")
          .attr("transform", function() { return "translate(9,5)" }); // slight offset
      });
    // UPDATE
    var params = animateIncremental();
    annot
      .selectAll("text").text(function (a) { return a.text; });
    annot
      .transition()
      .duration(params[0])
      .delay(function() { params[1](s,i) })
      .attr("transform", function(d) { return standardTranslate(s, d); });
    // EXIT
    annot.exit().remove();
  });
}

var MarkerEnum = {
  HIDDEN: 0,
  UNFOCUSED: 1,
  FOCUSED: 2
}
function updateMarkerSelect(md) {
  if (interactionMode == InteractEnum.SELECT) updateMarker(md);
}
function updateMarker(md) {
  // JOIN (singleton)
  if (md.st != MarkerEnum.HIDDEN && (typeof md.x == "undefined" || typeof md.y == "undefined")) {
    // give it a little help
    var r = calcCoords(md.s, xcoord2tix(md.mouse[0]));
    md.x = r[0];
    md.y = r[1];
  }
  var marker = svg.selectAll(".marker").data(d3.range(1));
  marker.enter().insert("circle")
    .attr("class", "marker")
    .style("stroke", "#000");
  // UPDATE
  marker
    .attr("cx", md.st == MarkerEnum.HIDDEN ? 0 : md.x)
    .attr("cy", md.st == MarkerEnum.HIDDEN ? 0 : md.y)
    .style("visibility", md.st == MarkerEnum.HIDDEN  ? "hidden" : "visible")
    .transition()
    .attr("r", md.st == MarkerEnum.FOCUSED ? 5 : 2)
    .style("stroke-width", md.st == MarkerEnum.FOCUSED ? 2 : 0)
    .style("fill",         md.st == MarkerEnum.FOCUSED ? d3.hsl(color(md.s.cid)).darker() : "#000");
}

function updateForm(fi) {
  // JOIN
  var annotForm = svg.selectAll(".annotForm").data(fi ? d3.range(1) : d3.range(0));
  var r = fi ? calcCoords(fi.s, fi.tix) : [0,0]; // hope these doesn't fuck me over too bad
  annotForm.enter().append("foreignObject")
    .attr("class", "annotForm")
    .attr("width", 250)
    .attr("height", "1.5em")
    .attr("x", r[0])
    .attr("y", r[1])
    .style("opacity", 0)
    .call(function(fo) {
      var old;
      var input = fo.append("xhtml:input").attr("type", "text")
        .each(function(inp) { // not guaranteed to exist!
          d3.select(this).node().focus();
          old = fi.s.annotations.filter(function(a) {return a.tix == fi.tix});
          // use the source here
          if (old.length) { // XXX there should only be one
            d3.select(this).node().value = old[0].text;
          }
        })
        .on("keyup", function() {
          if (d3.event.keyCode == 13) { // ENTER
            var text = input.node().value;
            $.post(backend + "/annotate/" + loc, {
              f2: fi.cid,
              f3: fi.tix,
              f4: text
              }, function() {
                var done = false;
                if (old.length) {
                  old[0].text = text;
                } else {
                  fi.s.annotations.push({tix: fi.tix, text: text });
                }
                updateAnnotations(slim);
                var r = calcCoords(fi.s, fi.tix);
                updateMarker({st: MarkerEnum.UNFOCUSED, x: r[0], y: r[1]});
                updateForm(false);
                interactionMode = InteractEnum.SELECT;
              });
            }
          })
        .on("blur", function() {
          setTimeout(function() {
            if (interactionMode != InteractEnum.SELECT) {
              updateMarker({st: MarkerEnum.HIDDEN});
              updateForm(false);
              interactionMode = InteractEnum.SELECT;
            }
          }, 200); // force it to run after
        });
      })
    .transition().duration(duration/4)
    .style("opacity", 1);
  // EXIT
  annotForm.exit().transition().duration(duration/8)
    .style("opacity", 0)
    .remove();
}

function animateIncremental() {
  var easing = function (t) {return 1 - (1-t)*(1-t)*(1-t);}
  var easeOver = showbands * 150;
  var delayCond = first || currGraph != GraphEnum.OVERLAY || nextGraph != GraphEnum.STACKED;
  var delayFun = function(d, i) { return delayCond ? 0 : easeOver * easing(i/showbands); };
  return [delayCond ? duration : duration/2, delayFun]
}

function updateAreas(symbols, cid) {
  // JOIN
  var symbol = svg.selectAll(".symbol").data(symbols);
  symbol.enter().append("g")
    .attr("class", "symbol")
  // UPDATE
  symbol.each(function(s, i) {
    // JOIN (boring)
    var band = d3.select(this).selectAll(".band").data(d3.range(1));
    band.enter().insert("path", ".line") // we want small areas to render on TOP
      .attr("class", "band")
      .style("fill", color(s.cid))
      .on("mouseover", function() {
        mouseoverBand(symbols, s.cid);
        updateMarkerSelect({st: MarkerEnum.UNFOCUSED, s: s, mouse: d3.mouse(svg.node())})
      })
      .on("mousemove", function() {
        updateMarkerSelect({st: MarkerEnum.UNFOCUSED, s: s, mouse: d3.mouse(svg.node())})
      })
      .on("mouseout", function() {
        mouseoutBand(symbols, s.cid);
        updateMarkerSelect({st: MarkerEnum.HIDDEN})
      })
      .on("click", function() {
        var mouse = d3.mouse(svg.node());
        if (interactionMode == InteractEnum.SELECT) {
          updateMarker({st: MarkerEnum.FOCUSED, s: s, mouse: mouse});
          updateForm({cid: s.cid, tix: xcoord2tix(mouse[0]), s: s});
          interactionMode = InteractEnum.ENTRY;
        } else if (interactionMode == InteractEnum.ENTRY) {
          updateForm(false);
          updateMarker({st: MarkerEnum.UNFOCUSED, s: s, mouse: mouse});
          interactionMode = InteractEnum.SELECT;
        }
      })
      ;
  });
  var params = animateIncremental();
  symbol.transition().duration(params[0])
    .select(".band")
      .delay(params[1])
      .style("opacity", function (s) { return s.cid == cid ? 1 : 0.6 })
      .attr("d", function(s) { return area(s.values); })
}

function updateLegend(symbols, cid) {
  // JOIN
  var legendrow = svg.selectAll(".legendrow").data(symbols);
  legendrow.enter().append("g")
    .attr("class", "legendrow")
    .each(function(s, i) {
      var cur = d3.select(this);
      cur.insert("rect")
        .attr("class", "bgbox")
        .attr("height", "22")
        .attr("width", margin.right-3)
        .attr("transform", "translate(-1,-1)")
      cur.insert("rect")
        .attr("class", "fgbox")
        .attr("width", "20")
        .attr("height", "20")
      cur.insert("text")
        .attr("transform", "translate(22,13)")
        .style("font-size", "12px")
        .text(cid2name(s.cid));
      cur.on("mouseover", function() {
        mouseoverBand(symbols, s.cid);
        });
      cur.on("mouseout", function() {
        mouseoutBand(symbols, s.cid);
        });
    });
  // UPDATE
  legendrow
    .attr("transform", function (s,i) { return "translate(" + (width + 20) + ", "+ (margin.top + i * 22) +")" });
  legendrow.selectAll(".bgbox")
    .style("fill", function(s) { return color(s.cid) })
    .style("opacity", function(s) { return s.cid == cid ? 0.6 : 0 });
  legendrow.selectAll(".fgbox")
    .style("fill", function (s) { return color(s.cid) })
    .style("opacity", function (s) { return s.cid == cid ? 1 : 0.6 });
}

function updatePie(symbols, cid) {
  var pielayout = d3.layout.pie().value(function(s) {return s.sumUsage;}).sort(null);
  var arc = d3.svg.arc().innerRadius(margin.right/2-50).outerRadius(margin.right/2-10);
  // JOIN
  var pie = svg.selectAll(".pie")
    .data(pielayout(symbols));
  pie.enter().append("path")
    .attr("class", "pie")
    .attr("fill", function(s) {return color(s.data.cid)})
    .attr("transform", "translate("+(width+margin.left+57)+","+(margin.top+margin.bottom+height-margin.right/2-50)+")")
    .attr("d", arc)
    .each(function(s) {
        this._current = s;
        var cur = d3.select(this);
        cur.on("mouseover", function() {mouseoverBand(symbols, s.data.cid)})
           .on("mouseout", function() {mouseoutBand(symbols, s.data.cid)});
        });
  // UPDATE
  pie
    .style("opacity", function(s) { return s.data.cid == cid ? 1 : 0.6 });
}

// ----------------------------------------------------------------------------
// Load the data!

d3.json(backend + "/view/" + loc, function(heap) {
  symbols   = heap.data;
  timetable = heap.timetable;
  nametable = heap.nametable;

  // domains are data dependent, calculated later
  x = d3.scale.linear().range([0, width])
                       .domain([tix2time(0), tix2time(timetable.length-1)]); // XXX modify me if we do vertical scrub
  y = d3.scale.linear().range([height, 0]).domain([0,0]);

  // some generators
  line = d3.svg.line()
      .interpolate(interpol)
      .x(function(d,i) { return x(tix2time(i)); })
      .y(function(d) { return y(d.y); });

  area = d3.svg.area()
      .interpolate(interpol)
      .x(function(d,i) { return x(tix2time(i)); })
      .y(height)

  // some extra calculations
  symbols.forEach(function(s) {
    s.maxUsage = d3.max(s.values, function(d) { return d.y; });
    s.sumUsage = d3.sum(s.values, function(d) { return d.y; });
  });

  slim = symbols.slice(0);
  slim.sort(function(a, b) { return b.maxUsage - a.maxUsage; });

  // we can't render everything, so split it up
  var high = slim.splice(0, showbands - 1);
  if (slim.length) {
    var s = {
      cid: -1,
      values: sumColumns(slim),
      annotations: []
    };
    s.maxUsage = d3.max(s.values, function(d) { return d.y; });
    s.sumUsage = d3.sum(s.values, function(d) { return d.y; });
    high.push(s);
  }
  others = slim; // save 'em up
  slim = high;
  // other might be a big band, so re-sort!
  slim.sort(function(a, b) { return b.maxUsage - a.maxUsage; });

  // symbols is the original data, slice is the new data; probably
  // this computation needs to be factored out...

  // aggregate counts for pie chart
  aggregate = sumColumns(slim); // XXX eliminate me

// ----------------------------------------------------------------------------
// Build some stuff

  // Order is important!
  updateAreas(slim);
  updateAnnotations(slim);
  updateLegend(slim);
  updatePie(slim);

  // some axes
  xaxis = d3.svg.axis().scale(x).orient("bottom");

  var bounds = [0, timetable.length-1];
  var moving;
  var vlines = svg.append("g").selectAll(".leyline")
    .data(bounds)
    .enter();
  function posleyline(m) {
    m.attr("x", function(d,i) {return i ? x(tix2time(d))+2 : 0})
     .attr("width", function(d,i) {return i ? (width-x(tix2time(d))-2) : x(tix2time(d))});
  }
  function postalisman(m) {
    m.attr("transform", function(d) {return "translate("+x(tix2time(d))+","+(height+30)+")";});
  }
  vlines.append("rect")
    .attr("class", "leyline")
    .attr("enable-background", "new")
    .style("fill", "#555")
    .style("opacity", 0.7)
    .attr("y", 0)
    .attr("height", height)
    .call(posleyline);
  vlines.append("path")
      .attr("class", "talisman")
      .style("opacity", 0.7)
      .call(postalisman)
      .attr("d", d3.svg.symbol().type("triangle-up").size(100))
      .on("dblclick", function() {
        var n = d3.select("#scrublock").node();
        n.checked = !n.checked;
      })
      .call(d3.behavior.drag()
       .on("dragstart", function(d,i) {dragging = true; moving = bounds[0] == bounds[1] ? -1 : i;})
       .on("dragend", function() {dragging = false})
       .on("drag", function() {
        var tix = xcoord2tix(d3.mouse(svg.node())[0]);
        var i = moving;
        if (d3.select("#scrublock").node().checked) {
          var width = bounds[1] - bounds[0];
          if (i == 0) {
            if (tix+width < timetable.length) {
              bounds = [tix, tix+width];
            } else {
              bounds = [timetable.length-1-width, timetable.length-1]
            }
          } else { // i == -1 OK here
            if (tix-width >= 0) {
              bounds = [tix-width, tix];
            } else {
              bounds = [0, width]
            }
          }
        } else {
          if (i == -1) {
            i = (tix > bounds[1]) ? 1 : i;
            i = (tix < bounds[0]) ? 0 : i;
            if (i == -1) return;
          }
          if (i == 0 && tix > bounds[1] || i == 1 && tix < bounds[0]) {
            return;
          } else {
            bounds[i] = tix;
          }
        }
        svg.selectAll(".talisman").data(bounds).call(postalisman);
        svg.selectAll(".leyline").data(bounds).call(posleyline);
        //pielayout.value(function(s) {return d3.sum()});
        piechart = piechart.data(pielayout(slim.map(function (s) {return {cid: s.cid, sumUsage: d3.sum(s.values.slice(bounds[0], bounds[1]+1), function(d) {return d.y})}})));
        piechart.transition().duration(50).attrTween("d", arcTween);
      }));

  function arcTween(a) {
    var i = d3.interpolate(this._current, a);
    this._current = i(0);
    return function(t) {
      return arc(i(t));
    };
  }

  svg.append("g")
    .attr("transform", "translate(0,"+height+")")
    .attr("class", "axis")
    .call(xaxis);

  yaxis = d3.svg.axis()
    .scale(y)
    .tickFormat(d3.format("s"))
    .orient("left");

  yaxisbox = svg.append("g")
    .attr("class", "axis")
    .call(yaxis);

  // alright, render time!
  setTimeout(function () { stackedArea(); first = false; }, 0);

});

function reset() {
  // reset interaction mode, not much else...
  interactionMode = InteractEnum.SELECT;
  updateMarker({st: MarkerEnum.HIDDEN});
  updateForm(false);
}

function stackedArea() {
  reset();
  nextGraph = GraphEnum.STACKED;
  var stack = d3.layout.stack()
      .values(function(s) { return s.values; })
      .x(function(d,i) { return tix2time(i); })
      .y(function(d) { return d.y; })
      .out(function(d, y0, y) { d.y0 = y0; })
      .order("reverse");

  stack(slim);

  y.domain([0, d3.max(slim[0].values.map(function(d) { return d.y + d.y0; }))])
  yaxisbox.call(yaxis);

  line
      .y(function(d) { return y(d.y0); });

  area
      .y0(function(d) { return y(d.y0); })
      .y1(function(d) { return y(d.y0 + d.y); });

  updateAreas(slim);
  updateAnnotations(slim);
  currGraph = GraphEnum.STACKED;
}

function normalizedStackedArea() {
  reset();
  nextGraph = GraphEnum.NORMALIZED;
  var stack = d3.layout.stack()
      .values(function(s) { return s.values; })
      .x(function(d,i) { return tix2time(i); })
      .y(function(d,i) { return d.y; })
      .out(function(d, y0, y) { d.y0 = y0; })
      .order("reverse");

  stack(slim);

  y
      .domain([0, 1]);
  yaxisbox.call(d3.svg.axis().orient("left").tickFormat(d3.format("%")).scale(y));

  line
      .y(function(d,i) { return y(d.y0/aggregate[i].y); });

  area
      .y0(function(d,i) { return y(d.y0/aggregate[i].y); })
      .y1(function(d,i) { return y((d.y0 + d.y)/aggregate[i].y); });

  var t = svg.selectAll(".symbol").transition()
        .duration(duration/2);

  t.select("path.band")
    .style("fill-opacity", 1)
    .attr("d", function(d) { return area(d.values); });
  svg.selectAll(".annotBand").each(function(s,i) {
    d3.select(this).selectAll("g.annot").transition().duration(duration/2)
    .attr("transform", function(d) { return standardTranslate(s,d) });
  });
  currGraph = GraphEnum.NORMALIZED;
}

function streamgraph() {
  reset();
  nextGraph = GraphEnum.STREAM;
  var stack = d3.layout.stack()
      .values(function(d) { return d.values; })
      .x(function(d,i) { return tix2time(i); })
      .y(function(d) { return d.y; })
      .out(function(d, y0, y) { d.y0 = y0; })
      .order("reverse")
      .offset("wiggle");

  stack(slim);

  y.domain([0, d3.max(slim[0].values.map(function(d) { return d.y + d.y0; }))])
  yaxisbox.call(yaxis);

  line
      .y(function(d) { return y(d.y0); });

  area
      .y0(function(d) { return y(d.y0); })
      .y1(function(d) { return y(d.y0 + d.y); });

  var t = svg.selectAll(".symbol").transition()
      .duration(duration);

  t.select("path.band")
      .attr("d", function(d) { return area(d.values); });

  t.select("path.line")
      .style("stroke-opacity", 1e-6)
      .attr("d", function(d) { return line(d.values); });
  t.select(".band")
      .style("fill-opacity", 1)
      .attr("d", function(d) { return area(d.values); });
  svg.selectAll(".annotBand").each(function(s) {
    d3.select(this).selectAll("g.annot").transition().duration(duration)
      .attr("transform", function(d) { return standardTranslate(s, d); });
  });
  currGraph = GraphEnum.STREAM;
}

function overlappingArea() {
  reset();
  nextGraph = GraphEnum.OVERLAY;
  var g = svg.selectAll(".symbol");

  y.domain([0, d3.max(slim[0].values.map(function(d) { return d.y + d.y0; }))])
  yaxisbox.call(yaxis);

  slim.forEach(function(s) {
      s.values.forEach(function(d) {d.y0 = 0;});
  });

  line
      .y(function(d) { return y(d.y0 + d.y); });

  g.select(".line")
      .attr("d", function(d) { return line(d.values); });

  area
      .y0(height)
      .y1(function(d) { return y(d.y); });

  line
      .y(function(d) { return y(d.y); });

  var t = g.transition()
      .duration(duration);

  t.select(".line")
      .style("stroke-opacity", 1)
      .attr("d", function(d) { return line(d.values); });

  t.select(".band")
      //.style("fill-opacity", .5)
      .attr("d", function(d) { return area(d.values); });

  svg.selectAll(".annotBand").each(function(s) {
    d3.select(this).selectAll("g.annot").transition().duration(duration)
      .attr("transform", function(d) { return standardTranslate(s, d); });
  });

  /*
  svg.append("line")
      .attr("class", "line")
      .attr("x1", 0)
      .attr("x2", width - 60)
      .attr("y1", height)
      .attr("y2", height)
      .style("stroke-opacity", 1e-6)
      .transition()
      .duration(duration)
      .style("stroke-opacity", 1);
      */
  currGraph = GraphEnum.OVERLAY;
}

function lineGraph() {
  reset();
  nextGraph = GraphEnum.LINE;
  var g = svg.selectAll(".symbol");

  y.domain([0, d3.max(slim[0].values.map(function(d) { return d.y + d.y0; }))])
  yaxisbox.call(yaxis);

  slim.forEach(function(s) {
      s.values.forEach(function(d) {d.y0 = 0;});
  });

  line
      .y(function(d) { return y(d.y0 + d.y); });

  g.select(".line")
      .attr("d", function(d) { return line(d.values); });

  area
      .y0(height)
      .y1(function(d) { return y(d.y); });

  line
      .y(function(d) { return y(d.y); });

  var t = g.transition()
      .duration(duration);

  t.select(".band")
      .style("stroke-opacity", 1)
      .style("fill", "none") // wrong
      .attr("d", function(d) { return line(d.values); });

  /*
  t.select(".band")
      .attr("d", function(d) { return area(d.values); });
      */

  svg.selectAll(".annotBand").each(function(s) {
    d3.select(this).selectAll("g.annot").transition().duration(duration)
      .attr("transform", function(d) { return standardTranslate(s, d); });
  });

  currGraph = GraphEnum.LINE;
}

    </script>
    <button onclick="streamgraph()">Stream Graph</button>
    <button onclick="stackedArea()">Stacked Graph</button>
    <button onclick="normalizedStackedArea()">Normalized Stacked Graph</button>
    <button onclick="overlappingArea()">Overlayed area Graph</button>
    <!--<button onclick="lineGraph()">Line Graph</button>--><br />
    Lock scrubs together: <input id="scrublock" type="checkbox" />
    <!--Filter: <input type="text" id="filter" onchange="" />-->
  </body>
</html>
