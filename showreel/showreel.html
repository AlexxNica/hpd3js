<!--
This is the famous Showreel example shipped with D3
http://bl.ocks.org/1256572
-->
<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script src="http://d3js.org/d3.v2.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
    <style type="text/css">

svg {
  display: block;
  margin: auto;
  font-family: "Helvetica Neue";
}

.line {
  fill: none;
  stroke: #000;
  stroke-width: 2px;
}

.tooltip {
  position: absolute;
  z-index: 10;
  background: #FFF;
}

.annot circle {
  stroke: #000;
  stroke-width: 2px;
}

.annot text {
  font-size: 12px;
}

.area {
  transition-property: opacity;
  transition-duration: 250ms;
  transition-timing-function: linear;
  opacity: 0.45;
}

.area:hover {
  opacity: 0.65;
}

    </style>
  </head>
  <body>
    <script type="text/javascript">

// some parameters

var interpol = "linear"; // "basis" will cause problems with annotation placement
var showbands = 10; // how many bands to show (the last band will be "OTHER")

// variable naming convention:
//    s = sequence (e.g. the entire "line" for a cost center)
//    d = data point (a particular (time, usage) point for a cost center)
//    a = annotation point
//    i,j,k = indexes

var tooltip = d3.select("body")
    .append("div")
    .attr("class", "tooltip")
    .style("visibility", "hidden");

var margin = {top: 10, right: 10, bottom: 10, left: 10},
    width = 800 - margin.right - margin.left,
    height = 500 - margin.top - margin.bottom;

var duration = 1500,
    delay = 500;

var annotCircleR = 5;
var annotCircleUnfocusR = 2;

var color = d3.scale.category10();

var svg = d3.select("body").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var first = true;
var form; // form element used to submit annotations

var symbols, // the main data set
    nametable, // array of cid (cost center id) to cost center name
    timetable; // array of tix (time index) to actual time (double)
var aggregate;

function cid2name(cid) {
    if (cid == -1) {
        return "OTHER";
    } else {
        return nametable[cid];
    }
}

function tix2time(tix) {
    return timetable[tix];
}

// outputs are {y: SUM}
function sumColumns(matrix) {
  return d3.transpose(matrix.map(function (s) {
     return s.values.map(function (d) { return d.y; });
  })).map(function (x) { return {y: d3.sum(x)}; })
}

var InteractEnum = {
  SELECT: 0, // we are selecting a data point to annotate
  ENTRY: 1   // we have an active form element for annotation
}
var interactionMode = InteractEnum.SELECT;

GraphEnum = {
  STACKED:0,
  STREAM:1,
  OVERLAY:2,
  NORMALIZED:3
  }
var currGraph = GraphEnum.STACKED;

// use these to calculate various parameters regardless of how we've scaled things
var x, y, line, axis, area;

//var backend = "http://heap.ezyang.com";
var backend = "http://localhost:3000";

// hack for ease of development
var loc = window.location.hash ? window.location.hash.substr(1) : "ee0029431bb4cf2941d0444782e7f291000214a6";

var marker; // the little circle which track your mouse

function calcCoords(s, tix) {
  return [x(tix2time(tix)), (first ? height : y((s.values[tix].y+s.values[tix].y0)/(currGraph == GraphEnum.NORMALIZED ? aggregate[tix].y : 1)))]
}

function standardTranslate(s, d) {
  var r = calcCoords(s, d.tix);
  return "translate("+r[0]+","+r[1]+")";
}

d3.json(backend + "/view/" + loc, function(heap) {
  symbols = heap.data;
  timetable = heap.timetable;
  nametable = heap.nametable;

  // domains are data dependent, calculated later
  x = d3.scale.linear().range([0, width - 60])
                       .domain([tix2time(0), tix2time(timetable.length-1)]); // XXX modify me if we do vertical scrub
  y = d3.scale.linear().range([height, 0]);

  // A line generator, for the dark stroke.
  line = d3.svg.line()
      .interpolate(interpol)
      .x(function(d,i) { return x(tix2time(i)); })
      .y(function(d) { return y(d.y); });

  // A line generator, for the dark stroke.
  axis = d3.svg.line()
      .interpolate(interpol)
      .x(function(d,i) { return x(tix2time(i)); })
      .y(height);

  // A area generator, for the dark stroke.
  area = d3.svg.area()
      .interpolate(interpol)
      .x(function(d,i) { return x(tix2time(i)); })
      .y(height)

  symbols.forEach(function(s) {
    s.maxUsage = d3.max(s.values, function(d) { return d.y; });
    s.sumUsage = d3.sum(s.values, function(d) { return d.y; });
  });
  symbols.sort(function(a, b) { return b.maxUsage - a.maxUsage; });

  // Separate high and low contributors
  var high = symbols.splice(0, showbands - 1);
  if (symbols.length) {
    // XXX saving annotations for other don't really work
    var s = {
           cid: -1,
           values: sumColumns(symbols),
           annotations: []
    };
    s.maxUsage = d3.max(s.values, function(d) { return d.y; });
    s.sumUsage = d3.sum(s.values, function(d) { return d.y; });
    high.push(s);
  }
  symbols = high;
  // other might be a big band, so re-sort!
  symbols.sort(function(a, b) { return b.maxUsage - a.maxUsage; });

  aggregate = sumColumns(symbols);

  // function because we can add new annotations on response to user input
  function doAnnotations(el, s) {
    var m = d3.select(el).selectAll(".annot")
      .data(s.annotations).enter()
      .insert("g").attr("class", "annot")
      .attr("transform", function(d) { return standardTranslate(s, d); });
    m.insert("circle")
      .attr("r", annotCircleR)
      .style("fill", color(s.cid))
    m.insert("text")
      .attr("transform", function() { return "translate(9,5)" }) // slight offset
      .text(function (a) { return a.text; });
  }

  var g = svg.selectAll("g.symbol")
      .data(symbols)
    .enter().append("g")
      .attr("class", "symbol");

  g.each(function(s, i) {
    // reverse engineers an SVG relative pixel into a tix
    // XXX move out, but has dependence on x()
    function calculateTix(xpixel) {
      var xinv = x.invert(xpixel);
      var rightCand = d3.bisectRight(timetable, xinv);
      var leftCand = rightCand-1;
      return leftCand < 0 || tix2time(rightCand)-xinv < xinv-tix2time(leftCand) ? rightCand : leftCand;
    }
    d3.select(this).selectAll(".area")
        .data(d3.range(1))
      .enter().insert("path", ".line")
        .attr("class", "area")
        .style("fill", color(s.cid))
        .attr("d", function(irrelevant) { return area(s.values); })
      .on("mouseover", function() {
        // D3 doesn't support concurrent disjoint transitions on the same
        // elements, so this causes visual artifacts. Disabled.
        //d3.select(d3.event.target).transition()
        //  .style("opacity", 1);
        tooltip.style("visibility", "visible").text(cid2name(s.cid));
        if (interactionMode == InteractEnum.SELECT) {
          marker.style("visibility", "visible");
        };
      })
      .on("mousemove", function() {
        tooltip.style("top", (d3.event.pageY-10)+"px")
                      .style("left",(d3.event.pageX+10)+"px");
        if (interactionMode == InteractEnum.SELECT) {
          var r = calcCoords(s, calculateTix(d3.mouse(svg.node())[0]));
          marker.attr("cx", r[0]).attr("cy", r[1]); // transition?
        };
      })
      .on("mouseout", function() {
        //d3.select(d3.event.target).transition()
        //  .style("opacity", .6);
        tooltip.style("visibility", "hidden");
        if (interactionMode == InteractEnum.SELECT) {
          marker.style("visibility", "hidden");
        }
      })
      .on("click", function() {
        var mouseinfo = d3.mouse(svg.node())[0];
        function blurit() {
          if (interactionMode != InteractEnum.SELECT) {
            interactionMode = InteractEnum.SELECT;
            marker.transition().duration(duration/4)
              .attr("r", annotCircleUnfocusR)
              .style("fill", "#000")
              .style("opacity", 0.7);
            form.transition().duration(duration/4)
              .style("opacity", 0)
              .remove();
            form = null;
          }
        }
        if (interactionMode == InteractEnum.SELECT) {
          var xcoord = calculateTix(d3.mouse(svg.node())[0]);
          interactionMode = InteractEnum.ENTRY;
          var r = calcCoords(s, calculateTix(mouseinfo));
          marker.transition().duration(duration/4)
            .attr("r", annotCircleR)
            .style("fill", color(s.cid))
            .style("opacity", 1)
            .attr("cx", r[0]).attr("cy", r[1]);
          form = svg.append("foreignObject");
          var input = form.append("xhtml:input");
          input.attr("type", "text")
            .on("keyup", function() {
              if (d3.event.keyCode == 13) { // ENTER
              var text = input.node().value;
              $.post(backend + "/annotate/" + loc, {
                  f2: s.cid,
                  f3: xcoord,
                  f4: text
                  }, function() {
                    blurit();
                    s.annotations.push({tix: xcoord, text: text });
                    // XXX blah
                    doAnnotations(svg.selectAll("g.symbol2").filter(function (x,j) { return i == j; }).node(), s);
                  });
              }
            })
            .on("blur", blurit);
            // XXX gotta watch out for double-event if you add blur and click
          var r = calcCoords(s, xcoord);
          form.attr("width", 250).attr("height", "1.5em").style("opacity", 0)
            .attr("x", r[0])
            .attr("y", r[1])
            .style("visibility", "visible")
            .transition().duration(duration/4)
            .style("opacity", 1);
          form.select("input").node().focus();
        } else if (interactionMode == InteractEnum.ENTRY) {
          blurit();
        }
      })
      ;
  });

  var g2 = svg.selectAll("g.symbol2")
          .data(symbols)
          .enter().append("g").attr("class", "symbol2");

  g2.each(function (d) { doAnnotations(this, d); });

  marker = svg.insert("circle")
    .attr("class", "edgeMark")
    .style("visibility", "hidden")
    .attr("r", annotCircleUnfocusR)
    .style("fill", "#000")
    .style("opacity", 0.7); // css-ize me

  setTimeout(function () { stackedArea(); first = false; }, 0);

});

function reset() {
  interactionMode = InteractEnum.SELECT;
  marker.style("visibility", "hidden");
  if (form) {
    form.transition().duration(duration/4)
              .style("opacity", 0)
              .remove();
    form = null;
  }
}

function stackedArea() {
  reset();
  var stack = d3.layout.stack()
      .values(function(s) { return s.values; })
      .x(function(d,i) { return tix2time(i); })
      .y(function(d) { return d.y; })
      .out(function(d, y0, y) { d.y0 = y0; })
      .order("reverse");

  stack(symbols);

  y.domain([0, d3.max(symbols[0].values.map(function(d) { return d.y + d.y0; }))])

  line
      .y(function(d) { return y(d.y0); });

  area
      .y0(function(d) { return y(d.y0); })
      .y1(function(d) { return y(d.y0 + d.y); });

  var t = svg.selectAll(".symbol").transition()
        .duration(duration/2);


  var easing = function (t) {
      return 1 - (1-t)*(1-t)*(1-t);
  }
  var easeOver = showbands * 150;

  var delayFun = function(d, i) { return (first||currGraph!=GraphEnum.OVERLAY) ? 0 : easeOver * easing(i/showbands); };

  t.select("path.area")
    .delay(delayFun)
    .style("fill-opacity", 1)
    .attr("d", function(d) { return area(d.values); });
  svg.selectAll(".symbol2").each(function(s,i) {
    d3.select(this).selectAll("g.annot").transition().duration(duration/2)
      .delay(function () { delayFun(s,i) })
      .attr("transform", function(d) { return standardTranslate(s, d); });
  });
  currGraph = GraphEnum.STACKED;
}

function normalizedStackedArea() {
  reset();
  var stack = d3.layout.stack()
      .values(function(s) { return s.values; })
      .x(function(d,i) { return tix2time(i); })
      .y(function(d,i) { return d.y; })
      .out(function(d, y0, y) { d.y0 = y0; })
      .order("reverse");

  stack(symbols);

  y
      .domain([0, 1])

  line
      .y(function(d,i) { return y(d.y0/aggregate[i].y); });

  area
      .y0(function(d,i) { return y(d.y0/aggregate[i].y); })
      .y1(function(d,i) { return y((d.y0 + d.y)/aggregate[i].y); });

  var t = svg.selectAll(".symbol").transition()
        .duration(duration/2);

  currGraph = GraphEnum.NORMALIZED;
  t.select("path.area")
    .style("fill-opacity", 1)
    .attr("d", function(d) { return area(d.values); });
  svg.selectAll(".symbol2").each(function(s,i) {
    d3.select(this).selectAll("g.annot").transition().duration(duration/2)
    .attr("transform", function(d) { return standardTranslate(s,d) });
  });
}

function streamgraph() {
  reset();
  var stack = d3.layout.stack()
      .values(function(d) { return d.values; })
      .x(function(d,i) { return tix2time(i); })
      .y(function(d) { return d.y; })
      .out(function(d, y0, y) { d.y0 = y0; })
      .order("reverse")
      .offset("wiggle");

  stack(symbols);

  y.domain([0, d3.max(symbols[0].values.map(function(d) { return d.y + d.y0; }))])

  line
      .y(function(d) { return y(d.y0); });

  area
      .y0(function(d) { return y(d.y0); })
      .y1(function(d) { return y(d.y0 + d.y); });

  var t = svg.selectAll(".symbol").transition()
      .duration(duration);

  t.select("path.area")
      .attr("d", function(d) { return area(d.values); });

  t.select("path.line")
      .style("stroke-opacity", 1e-6)
      .attr("d", function(d) { return line(d.values); });
  t.select(".area")
      .style("fill-opacity", 1)
      .attr("d", function(d) { return area(d.values); });
  svg.selectAll(".symbol2").each(function(s) {
    d3.select(this).selectAll("g.annot").transition().duration(duration)
      .attr("transform", function(d) { return standardTranslate(s, d); });
  });
  currGraph = GraphEnum.STREAM;
}

function overlappingArea() {
  reset();
  var g = svg.selectAll(".symbol");

  y.domain([0, d3.max(symbols[0].values.map(function(d) { return d.y + d.y0; }))])

  symbols.forEach(function(s) {
      s.values.forEach(function(d) {d.y0 = 0;});
  });

  line
      .y(function(d) { return y(d.y0 + d.y); });

  g.select(".line")
      .attr("d", function(d) { return line(d.values); });

  area
      .y0(height)
      .y1(function(d) { return y(d.y); });

  line
      .y(function(d) { return y(d.y); });

  var t = g.transition()
      .duration(duration);

  t.select(".line")
      .style("stroke-opacity", 1)
      .attr("d", function(d) { return line(d.values); });

  t.select(".area")
      //.style("fill-opacity", .5)
      .attr("d", function(d) { return area(d.values); });

  svg.selectAll(".symbol2").each(function(s) {
    d3.select(this).selectAll("g.annot").transition().duration(duration)
      .attr("transform", function(d) { return standardTranslate(s, d); });
  });

  /*
  svg.append("line")
      .attr("class", "line")
      .attr("x1", 0)
      .attr("x2", width - 60)
      .attr("y1", height)
      .attr("y2", height)
      .style("stroke-opacity", 1e-6)
      .transition()
      .duration(duration)
      .style("stroke-opacity", 1);
      */
  currGraph = GraphEnum.OVERLAY;
}

    </script>
    <button id="stream" onclick="streamgraph()">Stream Graph</button>
    <button id="stack" onclick="stackedArea()">Stacked Graph</button>
    <button id="normalized" onclick="normalizedStackedArea()">Normalized Stacked Graph</button>
    <button id="overlay" onclick="overlappingArea()">Overlayed area Graph</button></br>
  </body>
</html>
